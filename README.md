# Prisoners
This project is an experiment to test the *concurrency* and *message passing* abilities of the [Rust programming language](https://www.rust-lang.org/). It is mostly a training project for my personal use but feel free to open up issues or fork the project to create your own strategy. You might now think: *Strategy? What is he talking about?*. So, to prevent confusion, I will now explain the problem, I try to solve here.

## The Problem
The idea for this experiment came up when I started playing the game *Prison Architect* made by the people at [Introversion](http://www.introversion.co.uk/). By the time, I was playing the game, I had already played around with Rust and had even implemented a makeshift *interactive git shell*. But I had never visited the multi-threading and concurrency side of Rust. I just never had any problem to solve or any tool I wanted to build that would be a good target for concurrency.

Back to *Prison Architect*. While playing the game I thought a lot about how things might be solved in the game, technically. I thought a lot about how threads might have to be organized and how memory might be managed and also about how concurrency problems might be solved. After this whole lot of thinking, I came to the solution, that it would be best to just build a prison-like simulation myself. So I started constructing a similar but much simpler problem and came to the following scenario:

There are a number of *prisoners* (*Np*) in a prison, with a number of *needs* (*Nn*). The number of available *guards* is equal to the amount of needs, the prisoners might have. So every guard is able to satisfy exactly one need. Now, every prisoner technically lives in his own thread in the simulation. When the prisoner is having a problem, for example a need for *health*, *clothing* or *hygiene*, he sends a message to the respective guard, handling the message. The guards also are living in their own, separate threads. By handling, I mean, that he treats the need by sending a message back to the prisoner, telling him, that the need has been satisfied at the cost of the guard which in this case is *time*. Guards pay for their own services by taking a timeout. When for example a prisoner is sending a complaint message saying his need for *food* is at *20* (We use a primitive number system to prevent confusion and complication) the guard might respond with either *no action at all*, by *treating the problem* or, in case the prisoners need for something surpasses the *100* or underpasses the *-100* , sending a *kill* message telling the thread of the prisoner to terminate. Doing nothing at all, the guard of course doesn't have to take a timeout. Sending the kill message is also at no cost. Sending a treat message takes the time of the guard, so when the guard is treating a need, he can't do anything else. For example if the need for food of a prisoner is at *20*, it has to be treated with *20 seconds* of guard time. During that time, other prisoners are sending complaint messages to him. That means from time to time there might be more messages in a guards mailbox than he can handle. Prisoners might die. The task is, to solve this problem by keeping the prisoners at a stable level all the time.

## Possible Solutions
I think there are many ways to solve the problem. Some might think of a neural network or a simple state machine but for now my goal is to build a solid foundation for the threads and an architecture for the message passing that is ready for further development.